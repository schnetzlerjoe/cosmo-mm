import protobuf, { Service, Enum, MapField } from 'protobufjs';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var TYPES = {
    double: 'number',
    float: 'number',
    int32: 'number',
    int64: 'string',
    uint32: 'number',
    uint64: 'string',
    sint32: 'number',
    sint64: 'string',
    fixed32: 'number',
    fixed64: 'string',
    sfixed32: 'number',
    sfixed64: 'string',
    bool: 'boolean',
    string: 'string',
    bytes: 'string'
};
function getKeyType(p) {
    if (p.keyType) {
        return TYPES[p.keyType] || p.keyType;
    }
    return '';
}
function readField(name, content) {
    var params = Object.keys(content).map(function (paramName) {
        var paramValue = content[paramName];
        return {
            type: TYPES[paramValue.type] || paramValue.type,
            keyType: getKeyType(paramValue),
            name: paramName,
            rule: paramValue.rule,
            id: paramValue.id
        };
    });
    return {
        category: 'fields',
        name: name,
        params: params.sort(function (a, b) { return a.id - b.id; })
    };
}
function printField(name, fieldParams, options) {
    var content = fieldParams.fields;
    var item = readField(name, content);
    var strs = item.params.map(function (param) {
        if (param.rule === 'repeated') {
            return "  " + param.name + ": " + param.type + "[];\n";
        }
        if (param.keyType) {
            return "  " + param.name + ": {[key: " + param.keyType + "]: " + param.type + "};\n";
        }
        return "  " + param.name + ": " + param.type + ";\n";
    });
    // if (fieldParams.nested) {
    //   Object.keys(fieldParams.nested).forEach(key => {
    //     strs.push(`  ${key}: ${key};\n`);
    //   });
    // }
    var prefix = options.isDefinition ? '' : 'export ';
    return prefix + "interface " + item.name + " {\n" + strs.join('') + "}\n\n";
}

var EMPTY = 'google.protobuf.Empty';
function readMethod(name, content) {
    var params = Object.keys(content).map(function (paramName) {
        var paramValue = content[paramName];
        return __assign({ name: paramName }, paramValue);
    });
    return {
        category: 'methods',
        name: name,
        params: params
    };
}
function printMethod(name, methodContent, options) {
    var content = methodContent.methods;
    var item = readMethod(name, content);
    var strs = item.params.map(function (param) {
        var requestType = param.requestType === EMPTY ? '' : "params: " + param.requestType;
        var responseType = param.responseType === EMPTY ? '{}' : param.responseType;
        var prefix = options.isDefinition ? '' : 'export ';
        return (prefix + "interface " + param.name + " {\n" +
            ("  (" + requestType + "): Promise<" + responseType + ">;\n") +
            "}\n" +
            "\n");
    });
    return "" + strs.join('');
}

function printEnum(name, enumContent, options) {
    var content = enumContent.values;
    var item = Object.keys(content)
        .map(function (key) { return ({
        name: key,
        id: content[key]
    }); })
        .sort(function (a, b) { return a.id - b.id; });
    var strs = item.map(function (s) { return "  " + s.name + " = " + s.id + ",\n"; }).join('');
    var prefix = options.isDefinition ? '' : 'export ';
    return prefix + "enum " + name + " {\n" + strs + "}\n\n";
}

function _getAllMethods(root) {
    var service = root.nestedArray.find(function (s) { return s instanceof Service; });
    var firstService = root.lookupService(service.name);
    return firstService.methods;
}
function getAllMethods(source) {
    var res = protobuf.parse(source, {
        keepCase: true,
        alternateCommentMode: true
    });
    if (res.package) {
        var reflect = res.root.lookup(res.package);
        return _getAllMethods(reflect);
    }
    return _getAllMethods(res.root);
}
function mockScalar(type) {
    switch (type) {
        case 'string':
            return 'Hello';
        case 'number':
            return 10;
        case 'bool':
            return true;
        case 'int32':
            return 10;
        case 'int64':
            return '20';
        case 'uint32':
            return 100;
        case 'uint64':
            return '100';
        case 'sint32':
            return 100;
        case 'sint64':
            return '-1200';
        case 'fixed32':
            return 1400;
        case 'fixed64':
            return '1500';
        case 'sfixed32':
            return 1600;
        case 'sfixed64':
            return '-1700';
        case 'double':
            return 1.4;
        case 'float':
            return 1.1;
        case 'bytes':
            return new Buffer('Hello');
        default:
            return null;
    }
}
function mockType(root, typeName) {
    var type = root.lookupTypeOrEnum(typeName);
    if (type instanceof Enum) {
        var values = Object.values(type.values);
        return values[0];
    }
    var fieldMock = type.fieldsArray &&
        type.fieldsArray.reduce(function (a, b) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (b instanceof MapField) {
                var mockKey = mockScalar(b.keyType);
                var mockData_1 = mockScalar(b.type);
                var val_1 = mockData_1
                    ? (_a = {}, _a[b.name] = (_b = {}, _b[mockKey] = mockData_1, _b), _a) : (_c = {}, _c[b.name] = (_d = {}, _d[mockKey] = mockType(root, b.type), _d), _c);
                return __assign(__assign({}, a), val_1);
            }
            if (b.rule === 'repeated') {
                var mockData_2 = mockScalar(b.type);
                var val_2 = mockData_2
                    ? (_e = {}, _e[b.name] = [mockData_2], _e) : (_f = {}, _f[b.name] = [mockType(root, b.type)], _f);
                return __assign(__assign({}, a), val_2);
            }
            var mockData = mockScalar(b.type);
            var val = mockData
                ? (_g = {}, _g[b.name] = mockData, _g) : (_h = {}, _h[b.name] = mockType(root, b.type), _h);
            return __assign(__assign({}, a), val);
        }, {});
    // const enumMock =
    //   type.nestedArray &&
    //   type.nestedArray.reduce((a, b) => {
    //     if (b instanceof Enum) {
    //       const values = Object.values(b.values);
    //       if (values.length) {
    //         const val = { [b.name]: values[0] };
    //         return { ...a, ...val };
    //       }
    //       return a;
    //     }
    //     return a;
    //   }, {});
    return fieldMock;
}
function _mockResponse(root, methodName) {
    var service = root.nestedArray.find(function (s) { return s instanceof Service; });
    var firstService = root.lookupService(service.name);
    var responseType = firstService.methods[methodName].responseType;
    var res = mockType(root, responseType);
    return res;
}
function mockResponse(source, methodName) {
    var res = protobuf.parse(source, {
        keepCase: true,
        alternateCommentMode: true
    });
    if (res.package) {
        var reflect = res.root.lookup(res.package);
        return _mockResponse(reflect, methodName);
    }
    return _mockResponse(res.root, methodName);
}

var defaultOptions = {
    isDefinition: true
};
function printTypescript(json, options) {
    var nested = json.nested;
    if (nested) {
        var output = Object.keys(nested)
            .map(function (name) {
            var value = nested[name];
            var res = Object.keys(value).map(function (category) {
                if (category === 'fields')
                    return printField(name, value, options);
                if (category === 'methods')
                    return printMethod(name, value, options);
                if (category === 'values')
                    return printEnum(name, value, options);
                if (category === 'nested')
                    return printTypescript(value, options);
            });
            return res;
        })
            .reduce(function (a, b) { return a.concat(b); }, [])
            .join('');
        return output;
    }
    return '';
}
function parseProtoRoot(root, options, packageName) {
    if (packageName) {
        var _root = root.lookup(packageName);
        return printTypescript(_root.toJSON(), options);
    }
    return printTypescript(root.toJSON(), options);
}
function parseProto(source, _options) {
    var options = __assign(__assign({}, defaultOptions), _options);
    var res = protobuf.parse(source, { keepCase: true });
    return parseProtoRoot(res.root, options, res.package);
}
var index = {
    parseProto: parseProto,
    parseProtoRoot: parseProtoRoot,
    getAllMethods: getAllMethods,
    mockResponse: mockResponse
};

export default index;
export { getAllMethods, mockResponse, parseProto, parseProtoRoot, printTypescript };
